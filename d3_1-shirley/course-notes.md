Shirley!

http://slides.com/shirleywu/fm-d3intro#/
@sxywu
d3.unconf
metis?

# to-do
Read:  https://github.com/d3/d3/blob/master/API.md#selections-d3-selection
Learn: https://bl.ocks.org/-/about
Use:   https://blockbuilder.org/
Use:   https://blockbuilder.org/search


https://github.com/d3/d3/blob/master/API.md

# AGENDA
D3 Ecosystem

Selections
Data binding
Enter-append

Scales
Shapes

Update & Exit
Transitions

Forces

# D3 Ecosystem

API Reference:

Selections
Scales & Axes
Shapes
Forces

Bl.ocks & Blockbuilder (search)

# Selections and Data

https://github.com/d3/d3-selection

```html
  <svg>
    <rect />
    <rect />
    <rect />
    <rect />
    <rect />
  </svg>
  <script>
    var data = [100, 250, 175, 200, 120];
    
    d3.selectAll('rect')
    	.data(data)
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', 'blue')
    	.attr('stroke', '#fff');

  </script>
```

Let's analyse this script:

`d3.select/selectAll('css_selector')`
this returns an array with the DOM elements that you've selected, with some functions wrapped around it.
and then all the functions are available to use on these elements.

`.data(data)`
"here's where I think a lot of the magic happens": with this function you pass in an array of data, and d3 will bind the data, one to one, to the elements in your selection. Apparently it creates a property/attribute `__data__` in the element, and its value is the respective value in the array of data that was passed in.

The core of D3 is this: "you take some data and then you apply/bind it to the DOM element and then you can access the data because it's literally been bound to the element in this way."

```javascript
   	.attr('x', (d, i) => i * rectWidth)
   	.attr('y', d => height - d)
   	.attr('width', rectWidth)
   	.attr('height', d => d)
   	.attr('fill', 'blue')
    .attr('stroke', '#fff');
```
"Then once you've bound that to each of the elements, you can use that data do specify what your element should do" (or look like, I guess).

So what d3 does is: loop through each rectangle in the selection, and passes in the data that's been bound to that specific element, as well as the index of that element in that selection array that was generated by d3.select/selectAll. And then you basically use a function to apply that value, that is, to specify what you want returned as the value of, in this case, an attribute.

For example, in `.attr('x', (d, i) => i * rectWidth)` you're saying, "hey, for each of these rectangle elements, this is what I want my x attribute to be.".

Notar que essa função que vai buscar / calcular o valor que se quer atribuir ao atributo em questão deve sempre ter um `return`, para o d3 conseguir identificar o valor que vai ser usado. No entanto, dentro da definição da função, é possível incluir, por exemplo, um `console.log`.

```js
    d3.selectAll('rect')
    	.data(data)
    	.attr('x', function(d, i) {
        console.log(i, d, i * rectWidth, height - d); // logging
        return i * rectWidth})
    	.attr('y', d => height - d)
```

**svg**

Coordinate system goes like
         x
  0 ---------------- >
  |
  |
y |
  |
  |
  v

## Enter - Append

```html
  <svg></svg>
  <script>
    var rectWidth = 100;
    var height = 300;
    var data = [100, 250, 175, 200, 120];
    
    var svg = d3.select('svg');
    svg.selectAll('rect')
    	.data(data)
    	.enter().append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', 'blue')
    	.attr('stroke', '#fff');

  </script>
```

This piece of code gives the same result. It did not explicitly declared the <rect> elements.

But: `svg.selectAll('rect')` --> what are we even selecting?!

It's an empty selection! But how are those bars appearing?

Here's the magic: `.data(data).enter().append('rect')`

> So when we do .data and we enter in the set of data, we pass in the set of data like we did before. This's what .data is calculating. It's saying, here is all my data that I had been posting and this all the rectangle elements that exist on the screen right now which just happens to be zero. Which means I need five rectangles, I need to create five rectangles to match that data. And that's all .data figures out. 

> And then what .enter comes and does is, it says, okay, I need to have five place holders for the right elements to make sure it matches the data. So, it just puts in these five place holders. 

> And then finally, when you .append, it takes those placeholders and actually creates rectangle and rect elements out of them, and also at the same time binds all of that data. Yeah, so that's essentially what's happening for data Enter-Append

Exemplo 2, comentando a sequência.

```js
		var rectWidth = 100;
    var height = 300;
    var data = [100, 250, 175, 200, 120];
    
    var svg = d3.select('svg');
    let enter = svg.selectAll('rect');
//    	.data(data)
//    	.enter().append('rect')
//    	.attr('x', (d, i) => i * rectWidth)
//    	.attr('y', d => height - d)
//    	.attr('width', rectWidth)
//    	.attr('height', d => d)
//    	.attr('fill', 'blue')
//    	.attr('stroke', '#fff');
    console.log(enter);
```
Esse objeto `enter` vai estar vazio.

i. Aí tira o comentário da linha `.data(data)`. O objeto agora vai ter length 5, vazia por dentro.

> So `_groups` is essentially what D3 knows is on the screen.

Em `_enter`, vemos os 5 placeholders, vazios, mas com os respectivos valores de `data` associados.

ii. quando tira o comentário de `.enter()`, vemos os placeholders dentro de `_groups`.

iii. quando finalmente tira o de `.append('rect')`, we get the rectangles elements, with the data bound.

À medida que acrescentamos valores à array de dados, novos elementos vão sendo criados! 

> This is why D3 stands for data driven documents, because the idea is the dom should reflect the data that you have.

Como os valores que estão sendo atribuídos aos atributos vêm de funções, dá para fazer muitas coisas. Tipo, colorir com outra cor as barras de valor superior a tanto. 

> And that's the beauty of D 3 that once you have the data bound, you can do absolutely anything with it. You can return for the functions. You can do anything you want as long as it returns a valid value for that specific attribute.

```js
		var rectWidth = 50;
    var height = 300;
    var data = [100, 250, 175, 200, 120, 230, 50];
    let threshold = 230;
    
    var svg = d3.select('svg');
    let enter = svg.selectAll('rect')
    	.data(data)
    	.enter()
      .append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', function(d) {
        if (d > threshold) return 'firebrick'
        else return 'dodgerblue'})
    	.attr('stroke', '#fff');
    console.log(enter);
```
> How to check the state of the DOM elements on the screen and what data has been bound to them?

  <script>
		var rectWidth = 50;
    var height = 300;
    var data = [100, 250, 175, 200, 120, 230, 50];
    let threshold = 230;
    
    var svg = d3.select('svg');
    let selecao = svg.selectAll('rect')
    	.data(data)
    	.enter()
      .append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', function(d) {
        if (d>threshold) return 'firebrick'
        else return 'dodgerblue'})
    	.attr('stroke', '#fff');
    console.log(selecao);
    console.log(selecao.nodes());
    console.log(selecao._groups[0]);
  </script>

Esses dois últimos logs retornam essencialmente a mesma coisa.

(Mas `console.log(selecao.nodes() === selecao._groups[0])` retorna `false`.)

```js
  console.log(selecao);
  console.log(selecao.nodes());
  console.log(selecao._groups[0]);
  console.log(selecao.data());
```

Esse `selecao.data()`, com `data()` sem nenhum parâmetro, retorna uma array com os dados que foram amarrados.

> I think there's nothing really special about what D3 is doing So D3 is just supposed to be kind of this utility function, this tool to help you manipulate the DOM. So if you use SVG, if you use Canvas, if you use HTML, D3 is basically just a tool for you to manipulate that.

O exemplo de quando já existem dois <rect> hardcoded dentro de <svg>, e a matriz de dados tem 5 elementos. Com `.data()`, são criados placeholders para os rects que ainda não existem (3) e os dados (os três últimos elementos) são amarrados a esses três rects, e os dois <rect>s já existentes aparecem em `._groups`. Mas depois que é feito um `.append()`, só permanecem em `.groups` os três rects que foram criados por `.append()` (embora ele tenha um length de 5! Muito doido).

## Scales and Axes

> I like to think of it as like data binding is one of the core parts of D3 and then also enter-update-exit is one of the core parts of D3. And I personally maybe in a biased view think that if you just grasp those two the rest of the D3 library makes so much sense. Shirley Wu: Okay, so this is where we kinda go a little bit outside that core part and then just have a little bit of fun or what I think is fun

SCALE: mapping from *data attributes (domain)* to *to display (range)*

> for my examples thus far we give really nice values, right? Between zero to 200 renders nicely on the screen. But what if you had data whose values were between zero and one. If you just rendered that as height, it won't really show up for you. Or will like, if your height was you know a thousand something. Like 2,000, or 10,000 or something like that.


  


## Dúvidas

diferença de fazer um d3.select e um document.querySelector / .getElementsByTagName?
(como eram as seleções no JS mesmo?)
como selecionar parent, sibling etc., sem jquery?
<rect> properties?
como faz console log numa chamada do d3?
o que é o "0" em "_groups"?

